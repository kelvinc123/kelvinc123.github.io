<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://kelvinc123.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://kelvinc123.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-08-14T20:38:31+00:00</updated><id>https://kelvinc123.github.io/feed.xml</id><title type="html">blank</title><subtitle>Portfolio website. </subtitle><entry><title type="html">Exploring the Landscape of Generative Models: A Simple Guide</title><link href="https://kelvinc123.github.io/blog/2023/generative-model/" rel="alternate" type="text/html" title="Exploring the Landscape of Generative Models: A Simple Guide"/><published>2023-11-20T16:50:16+00:00</published><updated>2023-11-20T16:50:16+00:00</updated><id>https://kelvinc123.github.io/blog/2023/generative-model</id><content type="html" xml:base="https://kelvinc123.github.io/blog/2023/generative-model/"><![CDATA[<p>\(\DeclareMathOperator*{\argmin}{argmin}\) \(\DeclareMathOperator*{\argmax}{argmax}\)</p> <p>This blog offers a concise comparison of the most widely used generative models: Autoregressive Models, Normalizing Flow Models, Variational Autoencoders (VAEs), Generative Adversarial Networks (GANs), Energy-Based Models (EBMs), Score-Based Models, and the recently emerging Diffusion Models. Each of these models shared a common goal: to effectively model and represent the probability distribution \(p_{\theta}(\mathbf{x})\) of complex, high-dimensional dataset.</p> <p><br/></p> <h2 id="autoregressive">Autoregressive</h2> <p>Autoregressive (AR) models use the chain rule to model the probability of a high-dimensional dataset. For a given high-dimensional dataset \(\mathbf{x} \in \mathbb{R}^{n}\), the probability can be broken down into the product of conditional probabilities of <strong>each dimension given the preceding elements</strong>. More formally,</p> \[p_{\theta}(\mathbf{x}) = \prod_{i=1}^{n}p_{\theta}(x_{i} | x_{1}, x_{2}, \dots, x_{i-1})\] <p>This probabilistic breakdown facilitates the application of various assumptions, like the Markov assumption, or the integration of neural network architectures such as LSTMs or Transformer models. This decomposition allows the model to learn the probability distribution quickly and accurately. Autoregressive models have proven effective in generating sequential data, such as language modeling and time-series forecasting.</p> <h4 id="pros">Pros</h4> <ul> <li><b>Likelihood Estimation </b>: Provides the exact likelihood calculation as a result of chain rule</li> </ul> <h4 id="cons">Cons</h4> <ul> <li><b>Sampling speed</b>: Slow sampling speed due to the nature of sequential generation; each step requires the output from previous steps</li> <li><b>Scalability</b>: Struggles in handling a very large dataset and long sequences</li> </ul> <h4 id="references">References</h4> <ul> <li><strong>MADE: Masked Autoencoder for Distribution Estimation</strong> by Mathieu Germain, Karol Gregor, Iain Murray, and Hugo Larochelle. <a href="https://arxiv.org/abs/1502.03509">Link</a>.</li> <li><strong>Attention Is All You Need</strong> by Ashish Vaswani et al. <a href="https://arxiv.org/abs/1706.03762">Link</a>.</li> <li><strong>Pixel Recurrent Neural Networks</strong> by Aaron van den Oord and others. <a href="https://arxiv.org/abs/1601.06759">Link</a>.</li> <li><strong>Conditional Image Generation with PixelCNN Decoders</strong> by Aaron van den Oord and others. <a href="https://arxiv.org/abs/1606.05328">Link</a>.</li> </ul> <p><br/></p> <h2 id="normalizing-flow-models">Normalizing Flow Models</h2> <p>Normalizing Flow Models use a simple latent variable \(\mathbf{z}\), typically Gaussian, alongside a deterministic, invertible function \(f_{\theta}\) to model the probability distribution of the dataset \(p_{\theta}(\mathbf{x})\). The function \(f_{\theta}\) is defined so that \(f_{\theta}(\mathbf{z}) = \mathbf{x}\) and \(f_{\theta}^{-1}(\mathbf{x}) = \mathbf{z}\). The latent variable \(\mathbf{z}\) must match the dimensionality of \(\mathbf{x}\) to ensure that \(f_{\theta}\) is invertible. Note that the function \(f\) can be a composition of multiple invertible functions, \(f = f_{1} \circ f_{2} \dots \circ f_{n}\), enabling the construction of a complex function from simpler ones. The density of \(\mathbf{x}\) can then be formulated using the change of variable method:</p> \[p_{X}(\mathbf{x} ; \theta) = p_{Z}(\mathbf{z}) | \text{det} J_{f_{\theta}^{-1}}(\mathbf{z})|\] <p><br/> Here, \(\mathbf{z} = f_{\theta}^{-1}(\mathbf{x})\) and \(|\text{det} J_{f^{-1}}(\mathbf{z})|\) is the absolute value of the determinant of the jacobian matrix \(f^{-1}\).</p> <p>To evaluate the density of \(\mathbf{x}\), the mapping function \(f\) is used to transform \(\mathbf{x}\) to \(\mathbf{z}\) and use the right-hand side equation above to calculate the density \(p_{X}(\mathbf{x}; \theta)\). The simplicity of \(p_{Z}(\mathbf{z})\) is the key to computing \(p_{X}(\mathbf{x}; \theta)\). To generate new sample from \(p_{X}(\mathbf{x}; \theta)\), we can sample \(\mathbf{z}\) from the latent distribution \(p_{Z}(\mathbf{z})\) and apply \(f\) to obtain \(f(\mathbf{z}) = \mathbf{x}\).</p> <h4 id="pros-1">Pros</h4> <ul> <li><b>Likelihood Estimation </b>: Provides the exact likelihood calculation due to the change of variable formula</li> </ul> <h4 id="cons-1">Cons</h4> <ul> <li><b>Limitation in function selection</b>: The requirement for the mapping function f to be invertible and to maintain the same input-output dimension restrict the choice of functions</li> </ul> <h4 id="references-1">References</h4> <ul> <li><strong>Masked Autoregressive Flow for Density Estimation</strong> by George Papamakarios, Theo Pavlakou, and Iain Murray. <a href="https://arxiv.org/abs/1705.07057">Link</a>.</li> <li><strong>Normalizing Flows for Probabilistic Modeling and Inference</strong> by George Papamakarios, Eric Nalisnick, Danilo Jimenez Rezende, Shakir Mohamed, and Balaji Lakshminarayanan. <a href="https://arxiv.org/abs/1912.02762">Link</a>.</li> <li><strong>NICE: Non-linear Independent Components Estimation</strong> by Laurent Dinh, David Krueger, and Yoshua Bengio. <a href="https://arxiv.org/abs/1410.8516">Link</a>.</li> <li><strong>Gaussianization Flows</strong> by Chenlin Meng, Yang Song, Jiaming Song, and Stefano Ermon. <a href="https://arxiv.org/abs/2003.01941">Link</a>.</li> <li><strong>Density Estimation Using Real NVP</strong> by Laurent Dinh, Jascha Sohl-Dickstein, and Samy Bengio. <a href="https://arxiv.org/abs/1605.08803">Link</a>.</li> <li><strong>Glow: Generative Flow with Invertible 1x1 Convolutions</strong> by Diederik P. Kingma, and Prafulla Dhariwal. <a href="https://arxiv.org/abs/1807.03039">Link</a>.</li> </ul> <p><br/></p> <h2 id="variational-autoencoders">Variational Autoencoders</h2> <p>Variational Autoencoders (VAEs) are a class of generative model that models the probability distribution \(p_{\theta}(\mathbf{x})\) by learning a latent representation \(\mathbf{z}\) of the input data \(\mathbf{x}\). They consist of two main components: an encoder that maps input data to a latent distribution and a decoder that reconstructs the data from this latent space. Unlike the Normalizing Flow Model, this latent variable \(\mathbf{z}\) typically has a smaller dimension than the input data \(\mathbf{x}\). VAEs learn to maximize the evidence lower bound (ELBO) of the log probability of the dataset using the following formula:</p> \[\begin{align*} \log p_{\theta}(\mathbf{x}) &amp;\ge \textbf{ELBO}(\mathbf{x}, \theta, \phi) \\ &amp;= \mathbb{E}_{q_{\phi}(\mathbf{z} | \mathbf{x})}\left[\log\frac{p_{\theta}(\mathbf{x}, \mathbf{z})}{q_{\phi}(\mathbf{z} | \mathbf{x})}\right] \\ &amp;= \mathbb{E}_{q_{\phi}(\mathbf{z} | \mathbf{x})}[\log p_{\theta}(\mathbf{x}| \mathbf{z})] - D_{\text{KL}}(q_{\phi}(\mathbf{z} | \mathbf{x}) || p(\mathbf{z})) \end{align*}\] <p><br/> In this setup, the \(p(\mathbf{z})\) is usually a simple distribution like Gaussian. The term \(q_{\phi}(\mathbf{z} | \mathbf{x})\) and \(p_{\theta}(\mathbf{x} | \mathbf{z})\) are usually called the encoder and decoder respectively. To sample from VAEs, we first need to sample the latent \(\mathbf{z}\) from \(p(\mathbf{z})\) and use the decoder component \(p_{\theta}(\mathbf{x} | \mathbf{z})\) to transform \(z\) to the sample.</p> <h4 id="pros-2">Pros</h4> <ul> <li><b>Latent Representation</b>: Creates a meaningful lower-dimensional representation of the input data</li> <li><b>Sampling speed</b>: Fast sampling speed, requiring only a forward pass through the decoder</li> </ul> <h4 id="cons-2">Cons</h4> <ul> <li><b>Approximate of true distribution</b>: Doesn't exactly compute the true distribution; it uses the approximation via ELBO</li> </ul> <h4 id="references-2">References</h4> <ul> <li><strong>Auto-Encoding Variational Bayes</strong> by Diederik P Kingma and Max Welling. <a href="https://arxiv.org/abs/1312.6114">Link</a>.</li> <li><strong>Disentangling Disentanglement in Variational Autoencoders</strong> by Emile Mathieu, Tom Rainforth, N. Siddharth, Yee Whye Teh. <a href="https://arxiv.org/abs/1812.02833">Link</a>.</li> <li><strong>Understanding disentangling in beta-VAE</strong> by Christopher P. Burgess, Irina Higgins, Arka Pal, Loic Matthey, Nick Watters, Guillaume Desjardins, Alexander Lerchner. <a href="https://arxiv.org/abs/1804.03599">Link</a>.</li> </ul> <p><br/></p> <h2 id="generative-adversarial-networks">Generative Adversarial Networks</h2> <p>Generative Adversarial Networks (GANs) are generative models that do not directly model the probability distribution \(p_{\theta}(\mathbf{x})\) of the dataset. Instead, GANs focus on producing high-quality samples. GANs have two main components: a discriminator \(D\) and a generator \(G\). The discriminator acts as a binary classifier distinguishing real from generated samples. At the same time, the generator tries to fool the discriminator by generating fake samples from a random variable \(\mathbf{z}\) drawn from a prior distribution \(p(\mathbf{z})\). These two components can be formulated as a minimax game with the value function:</p> \[\min_{G} \max_{D}V(D, G) = \mathbb{E}_{\mathbf{x} \sim p_{\text{data}}(\mathbf{x})}[\log D(\mathbf{x})] + \mathbb{E}_{\mathbf{z} \sim p(\mathbf{z})}[\log (1 - D(G(\mathbf{z})))]\] <p><br/> In this adversarial setup, \(G\) and \(D\) are updated sequentially. The discriminator sharpens its ability to distinguish real from fake, while the generator improves at creating increasingly convincing fake data. To generate new samples, we first sample \(\mathbf{z} \sim p(\mathbf{z})\) and then feed it into the generator.</p> <h4 id="pros-3">Pros</h4> <ul> <li><b>Sample quality</b>: Known for producing high-quality samples as a result of the minimax game</li> <li><b>Sampling speed</b>: Fast sampling speed, requiring only a forward pass through the generator</li> </ul> <h4 id="cons-3">Cons</h4> <ul> <li><b>Lack of probability estimation</b>: GANs do not focus maximum likelihood estimation, hence are unable to compute probabilities or bounds like VAEs</li> <li><b>Mode collapse</b>: Sometimes the generator only produces the limited variety of outputs</li> <li><b>Training complexity</b>: GANs are difficult to train, sensitive to the hyperparameters, and often face stability issues</li> </ul> <h4 id="references-3">References</h4> <ul> <li><strong>Generative Adversarial Networks</strong> by Ian J. Goodfellow and colleagues. <a href="https://arxiv.org/abs/1406.2661">Link</a>.</li> <li><strong>Wasserstein GAN</strong> introducing a new training approach for GANs. <a href="https://arxiv.org/abs/1701.07875">Link</a>.</li> <li><strong>f-GAN: Training Generative Neural Samplers using Variational Divergence Minimization</strong> by Sebastian Nowozin, Botond Cseke, Ryota Tomioka. <a href="https://arxiv.org/abs/1606.00709">Link</a>.</li> <li><strong>Conditional Generative Adversarial Nets</strong> by Mehdi Mirza, Simon Osindero. <a href="https://arxiv.org/abs/1411.1784">Link</a>.</li> </ul> <p><br/></p> <h2 id="energy-based-models">Energy-Based Models</h2> <p>Energy-Based Models (EBMs) estimate the probability distribution of a dataset \(p_{\theta}(\mathbf{x})\) directly using the energy function \(E_{\theta}(\mathbf{x})\). Unlike the other generative models, the energy function defines an unnormalized negative log probability, which is less restrictive. To ensure that \(p_{\theta}(\mathbf{x})\) is a valid probability function, it must be nonnegative and integrate to \(1\). Therefore, the probability density function of EBM is expressed as:</p> \[p_{\theta}(\mathbf{x}) = \frac{\exp(-E_{\theta}(\mathbf{x}))}{Z_{\theta}}\] <p>Where \(Z_{\theta}\) is the normalizing constant (or partition function) for the exponentiation of the energy function. Although the \(Z_{\theta}\) here is constant, it’s still a function of \(\theta\). For training EBMs, we can use maximum likelihood learning. The gradient of the \(\log p_{\theta}(\mathbf{x})\) w.r.t \(\theta\) is:</p> \[\begin{align*} \nabla_{\theta}\log p_{\theta}(\mathbf{x}) &amp;= -\nabla_{\theta}E_{\theta}(\mathbf{x}) - \mathbb{E}_{\mathbf{x}_{\text{sample}} \sim p_{\theta}(\mathbf{x})}[\nabla_{\theta}E_{\theta}(\mathbf{x}_{\text{sample}})] \\ &amp;\approx -\nabla_{\theta}E_{\theta}(\mathbf{x}) - \nabla_{\theta}E_{\theta}(\mathbf{x}_{\text{sample}}) \end{align*}\] <p>Here, \(\mathbf{x}_{\text{sample}}\) is drawn from our EBM \(p_{\theta}(\mathbf{x_{\text{sample}}})\). Unfortunately, the sampling process can be challenging as it needs the MCMC methods such as Metropolish Hastings or Langevin dynamics. The iterative Langevin MCMC sampling procedure is:</p> \[\mathbf{x}^{(k+1)} \leftarrow \mathbf{x}^{(k)} + \frac{\epsilon}{2} \nabla_{\mathbf{x}}\log p_{\theta}(\mathbf{x}^{(k)}) + \epsilon \mathbf{z}^{(k)}\] <p>Where \(\mathbf{z}^{k}\) is a standard Gaussian random variable. This process converges to the EBM’s distribution \(p_{\theta}(\mathbf{x})\) as \(\epsilon \rightarrow 0\) and \(k \rightarrow \infty\).</p> <h4 id="pros-4">Pros</h4> <ul> <li><b>Energy function architecture</b>: Flexibility in choosing the energy function</li> <li><b>Direct modeling of probability</b>: Capable of modeling the probability distribution directly, without the need for an intermediate latent space</li> <li><b>Robust to overfitting</b>: EBMs are generally more robust to overfitting compared to other generative models</li> </ul> <h4 id="cons-4">Cons</h4> <ul> <li><b>Sampling speed</b>: The need for the MCMC sampling method to converge makes sampling very slow</li> <li><b>Training speed</b>: Each training iteration requires sampling, which is very slow</li> <li><b>Difficulty in probability estimation</b>: While EBMs model probabilities directly, calculating the partition function is often intractable</li> </ul> <h4 id="references-4">References</h4> <ul> <li><strong>How to Train Your Energy-Based Models</strong> by Yang Song, Diederik P. Kingma. <a href="https://arxiv.org/abs/2101.03288">Link</a>.</li> <li><strong>Flow Contrastive Estimation of Energy-Based Models</strong> by Ruiqi Gao, Erik Nijkamp, Diederik P. Kingma, Zhen Xu, Andrew M. Dai, Ying Nian Wu. <a href="https://arxiv.org/abs/1912.00589">Link</a>.</li> </ul> <p><br/></p> <h2 id="score-based-models">Score-Based Models</h2> <p>Score-Based models offer a unique approach to generative modeling. Unlike the other traditional generative models, Score-Based Models do not explicitly model the probability distribution of the dataset. Instead, they focus on approximating the gradient of the log probability \(\nabla_{\mathbf{x}}\log p_{\theta}(\mathbf{x})\), through a score function \(s_{\theta}(\mathbf{x})\). One method to train these models is by learning the <em>Noise Conditional Score Networks</em> (NCSN), denoted by \(s_{\theta}(\mathbf{x}, \sigma)\), where the goal is to predict scores for perturbed datasets at varying noise levels, \(\sigma\). The objective function for a given noise level \(\sigma\) is:</p> \[\mathcal{l}(\theta; \sigma) = \mathbb{E}_{p_{\text{data}}}\mathbb{E}_{\tilde{\mathbf{x}}\sim\mathcal{N}(\mathbf{x}, \sigma^{2}I)}\left[\left|\left|s_{\theta}(\tilde{\mathbf{x}}, \sigma) + \frac{\tilde{\mathbf{x}} - \mathbf{x}}{\sigma^{2}}\right|\right|^{2}_{2}\right]\] <p>This function is based on the denoising score matching technique, where training the score function of the data with added noise is equivalent to training the denoising objective. The denoising objective’s goal is to gradually denoise data, starting from a pure noise distribution. The combined objective function across different levels of \(\sigma\) is:</p> \[\mathcal{L}(\theta; \{\sigma_{i}\}_{i=1}^{L}) = \frac{1}{L}\sum_{i=1}^{L}\lambda(\sigma_{i})\mathcal{l}(\theta; \sigma_{i})\] <p>To generate samples from the NCSN, the <em>Annealed Langevin Dynamics</em> is employed. The idea is to run Langevin dynamics iterations scaled by the noise level for each noise level. The <em>Annealed Langevin Dynamics</em> algorithm can be seen below:</p> <figure text-align="center" margin="0 auto" display="block"> <img class="img-fluid rounded z-depth-1" src="/assets/img/annealed-ld.jpg" alt="Annealed Langevin Dynamics Algorithm" width="350" data-zoomable=""/> <figcaption>Langevin Dynamics Algorithm. (Image source: <a href="https://arxiv.org/abs/1907.05600" target="_blank" data-zoomable="">Song, Y., &amp; Ermon, S. (2019)</a>)</figcaption> </figure> <h4 id="pros-5">Pros</h4> <ul> <li><b>Sample quality</b>: Produces superior results compared to the other generative models</li> <li><b>Flexible model architecture</b>: The score function's architecture is less constrained, allowing for various designs as long as input and output dimensions match</li> <li><b>Training simplicity</b>: Leveraging denoising tasks simplifies the training process</li> </ul> <h4 id="cons-5">Cons</h4> <ul> <li><b>Sampling speed</b>: The reliance on Annealed Langevin Dynamics for sampling can be time-consuming</li> <li><b>Lack in probability estimation</b>: The indirect modeling approach complicates exact probability distribution calculations</li> </ul> <h4 id="references-5">References</h4> <ul> <li><strong>Generative Modeling by Estimating Gradients of the Data Distribution</strong> by Yang Song and Stefano Ermon. <a href="https://arxiv.org/abs/1907.05600">Link</a>.</li> <li><strong>Improved Techniques for Training Score-Based Generative Models</strong> by Yang Song and Stefano Ermon. <a href="https://arxiv.org/abs/2006.09011">Link</a>.</li> <li><strong>Score-Based Generative Modeling through Stochastic Differential Equations</strong> by Yang Song, Jascha Sohl-Dickstein, Diederik P. Kingma, Abhishek Kumar, Stefano Ermon, and Ben Poole. <a href="https://arxiv.org/abs/2011.13456">Link</a>.</li> <li><strong>Maximum Likelihood Training of Score-Based Diffusion Models</strong> by Yang Song, Conor Durkan, Iain Murray, and Stefano Ermon. <a href="https://arxiv.org/abs/2101.09258">Link</a>.</li> </ul> <p><br/></p> <h2 id="diffusion-models">Diffusion Models</h2> <p>Diffusion Models stand as a pinnacle in the field of generative models. These models operate through a unique process that gradually adds Gaussian noise to the dataset until the data is purely random. This process of adding noises is called the <em>forward process</em>. More formally, for a given initial dataset \(\mathbf{x}_{0}\), Diffusion Models sequentially add a Gaussian noise, adhering to the Markov assumption. This is mathematically represented as:</p> \[q(x_{0}) = p_{\text{data}}(\mathbf{x}_{0})\] <p>and</p> \[q(\mathbf{x}_{1:T} | \mathbf{x}_{0}) \prod_{i=1}^{T}q(\mathbf{x}_{t} | \mathbf{x}_{t-1}), \hspace{1.5cm} q(\mathbf{x}_{t} | \mathbf{x}_{t-1}) = \mathcal{N}(\sqrt{1 - \beta_{t}}\mathbf{x}_{t-1}, \beta_{t}I)\] <p>where \(\beta_{t}\) is a noise level parameters.</p> <p>Diffusion Models mirror the principle of Variational Autoencoders (VAEs) in learning the probability distribution \(p_{\theta}(\mathbf{x}_{0})\). This is achieved by maximizing the Evidence Lower Bound (ELBO), expressed as:</p> \[\begin{align*} \log p_{\theta}(\mathbf{x}_{0}) &amp;\ge \textbf{ELBO}(\mathbf{x}, \theta) \\ &amp;= \mathbb{E}_{q}\left[\log\frac{p_{\theta}(\mathbf{x}_{0:T})}{q(\mathbf{x}_{1:T} | \mathbf{x}_{0})}\right] \\ \end{align*}\] <p>Here, the joint probability \(p_{\theta}(\mathbf{x}_{0:T})\), also defined under the Markov assumption as follows:</p> \[p_{\theta}(\mathbf{x}_{0:T}) = p(\mathbf{x}_{T}) \prod_{i=1}^{T}p_{\theta}(\mathbf{x}_{t-1} | \mathbf{x}_{t}), \hspace{1.5cm} p_{\theta}(\mathbf{x}_{t-1} | \mathbf{x}_{t}) = \mathcal{N}(\mu_{\theta}(\mathbf{x}_{t}, t), \Sigma_{\theta}(\mathbf{x}_{t}, t))\] <p>This joint distribution signifies the <em>reverse process</em>, which attempts to revert the forward process by denoising the noise.</p> <p>Note that the difference between VAEs and Diffusion Models lies in the distribution of \(q\). In the Diffusion Model, \(q\) is fixed and doesn’t depend on any trainable parameters. This framework aligns with the training objective of Score-Based Models, essentially focusing on learning the denoising process. The training objective can be simplifies to learning the noise \(\epsilon(\mathbf{x}_{t}, t)\) at a specific time \(t\) by minimizing the following simplified loss:</p> \[\mathcal{L}(\theta) := \mathbb{E}_{t, \mathbf{x}_{0}, \epsilon}\left[\left|\left|\epsilon - \epsilon(\mathbf{x}_{t}, t)\right|\right|_{2}^{2}\right]\] <p>To sample from the Diffusion Models, one begins by sampling random noise from the distribution \(p(\mathbf{x}_{T})\) and gradually takes a denoising step until \(\mathbf{x}_{0}\) is formed. This sampling procedure is similar to the denoising score matching process. Below is the sampling algorithm for Diffusion Models:</p> <figure text-align="center" margin="0 auto" display="block"> <img class="img-fluid rounded z-depth-1" src="/assets/img/ddpm-sampling.jpg" alt="Diffusion Models Sampling Algorithm" width="350" data-zoomable=""/> <figcaption>Diffusion Model Sampling Algorithm. (Image source: <a href="https://arxiv.org/abs/2006.11239" target="_blank" data-zoomable="">Jonathan Ho, Ajay Jain, and Pieter Abbeel (2020)</a>)</figcaption> </figure> <h4 id="pros-6">Pros</h4> <ul> <li><b>Sample quality</b>: Excel in producing high-quality and detailed samples</li> <li><b>Latent Representation</b>: Able to get a latent representation of the dataset</li> </ul> <h4 id="cons-6">Cons</h4> <ul> <li><b>Sample speed</b>: The denoising steps makes sampling very slow</li> </ul> <h4 id="references-6">References</h4> <ul> <li><strong>Denoising Diffusion Probabilistic Models</strong> by Jonathan Ho, Ajay Jain, Pieter Abbeel. <a href="https://arxiv.org/abs/2006.11239">Link</a>.</li> <li><strong>Improved Denoising Diffusion Probabilistic Models</strong> by Alex Nichol, Prafulla Dhariwal. <a href="https://arxiv.org/abs/2102.09672">Link</a>.</li> <li><strong>Diffusion Models Beat GANs on Image Synthesis</strong> by Prafulla Dhariwal, Alex Nichol. <a href="https://arxiv.org/abs/2105.05233">Link</a>.</li> <li><strong>Denoising Diffusion Implicit Models</strong> by Jiaming Song, Chenlin Meng, Stefano Ermon. <a href="https://arxiv.org/abs/2010.02502">Link</a>.</li> <li><strong>High-Resolution Image Synthesis with Latent Diffusion Models</strong> by Robin Rombach, Andreas Blattmann, Dominik Lorenz, Patrick Esser, Björn Ommer. <a href="https://arxiv.org/abs/2112.10752">Link</a>.</li> <li><strong>Photorealistic Text-to-Image Diffusion Models with Deep Language Understanding</strong> by Chitwan Saharia, William Chan, Saurabh Saxena, Lala Li, Jay Whang, Emily Denton, Seyed Kamyar Seyed Ghasemipour, Burcu Karagol Ayan, S. Sara Mahdavi, Rapha Gontijo Lopes, Tim Salimans, Jonathan Ho, David J Fleet, Mohammad Norouzi. <a href="https://arxiv.org/abs/2205.11487">Link</a>.</li> </ul> <h2 id="other-comments">Other Comments</h2> <p>I hope you found this guide informative and useful. If you have any questions, notice any inaccuracies, or simply wish to discuss these fascinating models further, feel free to reach out in the comments or contact me directly. Your feedback and engagement are always appreciated!</p>]]></content><author><name></name></author><category term="generative-models"/><category term="VAE"/><category term="Autoregressive"/><category term="Flow"/><category term="Energy-Based"/><category term="Score-Based"/><category term="GAN"/><category term="Diffusion"/><summary type="html"><![CDATA[Simple comparison between Autoregressive, Flow, VAEs, GANs, Energy-Based, Score-Based, and Diffusion models.]]></summary></entry><entry><title type="html">The Dual Nature of MLE and KL Divergence in Generative Modeling</title><link href="https://kelvinc123.github.io/blog/2023/kl-mle/" rel="alternate" type="text/html" title="The Dual Nature of MLE and KL Divergence in Generative Modeling"/><published>2023-11-05T16:50:16+00:00</published><updated>2023-11-05T16:50:16+00:00</updated><id>https://kelvinc123.github.io/blog/2023/kl-mle</id><content type="html" xml:base="https://kelvinc123.github.io/blog/2023/kl-mle/"><![CDATA[<p>\(\DeclareMathOperator*{\argmin}{argmin}\) \(\DeclareMathOperator*{\argmax}{argmax}\)</p> <h2 id="kl-divergence">KL-Divergence</h2> <p>In generative modeling, we assume the existence of a true probability distribution \(p_{\text{data}}\) of our dataset. However, this distribution is usually unknown. We aim to approximate the true data distribution \(p_{\text{data}}\), with a model distribution \(p_{\theta}\), parameterized by \(\theta\), striving for the closest possible match. One solution to achieve this is to find \(\theta^{*}_{\text{KL}}\) that minimizes the <strong>Kullback–Leibler divergence</strong> between \(p_{\text{data}}\) and \(p_{\theta}\).</p> <p>Recall that the KL-divergence of the 2 probabilities \(p\) and \(q\) is given by:</p> \[D_{\text{KL}}(p || q) = \mathbb{E}_{\mathbf{x} \sim p(\mathbf{x})}\left[\log \left(\frac{p(\mathbf{x})}{q(\mathbf{x})}\right)\right]\] <p>with three properties:</p> <ol> <li> $$D_{\text{KL}}(p || q) \ge 0$$</li> <li> $$D_{\text{KL}}(p || q) = 0 \text{ if and only if } p=q$$</li> <li> $$D_{\text{KL}}(p || q) \ne D_{\text{KL}}(q || p)$$</li> </ol> <p><br/> Our objective is to find the parameter \(\theta^{*}_{\text{KL}}\) that minimizes the function \(D_{\text{KL}}(p_{\text{data}} || p_{\theta})\). Note that \(D_{\text{KL}}(p_{\text{data}} || p_{\theta})\) is preferred over \(D_{\text{KL}}(p_{\theta} || p_{\text{data}})\) because the expectation in the former is with respect to \(p_{\text{data}}\), the true data distribution, whereas in the latter, it is with respect to \(p_{\theta}\). We can further expand the objective equation to:</p> \[\begin{align} \theta^{*}_{\text{KL}} &amp;= \argmin\limits_{\theta} D_{\text{KL}}(p_{\text{data}} || p_{\theta}) \\ &amp;= \argmin\limits_{\theta} \mathbb{E}_{\mathbf{x} \sim p_{\text{data}}(\mathbf{x})}\left[\log \left(\frac{p_{\text{data}}(\mathbf{x})}{p_{\theta}(\mathbf{x})}\right)\right] \\ &amp;= \argmin\limits_{\theta} \mathbb{E}_{\mathbf{x} \sim p_{\text{data}}(\mathbf{x})}\left[\log (p_{\text{data}}(\mathbf{x})) - \log (p_{\theta}(\mathbf{x}))\right] \\ &amp;= \argmin\limits_{\theta} \left(\mathbb{E}_{\mathbf{x} \sim p_{\text{data}}(\mathbf{x})}\left[\log (p_{\text{data}}(\mathbf{x}))] - \mathbb{E}_{\mathbf{x} \sim p_{\text{data}}(\mathbf{x})}[\log (p_{\theta}(\mathbf{x}))\right] \right) \\ &amp;= \argmin\limits_{\theta} - \mathbb{E}_{\mathbf{x} \sim p_{\text{data}}(\mathbf{x})}[\log (p_{\theta}(\mathbf{x}))] \\ &amp;= \argmax\limits_{\theta} \mathbb{E}_{\mathbf{x} \sim p_{\text{data}}(\mathbf{x})}[\log (p_{\theta}(\mathbf{x}))] \end{align}\] <p>The term \(\mathbb{E}_{\mathbf{x} \sim p_{\text{data}}(\mathbf{x})}[\log (p_{\text{data}}(\mathbf{x}))]\) is a constant with respect to \(\theta\). Therefore, the equation \((3)\) is equivalent to the equation \((4)\). Since the last equation is in expectation, we can use sampling to calculate the empirical approximation of the expectation. Given the presupposition of a true underlying distribution \(p_{\text{data}}\), we can represent our dataset as a series of samples \(\mathbf{x}^{(1)}, \mathbf{x}^{(2)}, \dots, \mathbf{x}^{(n)}\) drawn from \(p_{\text{data}}(\mathbf{x})\), which leads us to the following derivation:</p> \[\begin{align} \argmin\limits_{\theta} D_{\text{KL}}(p_{\text{data}} || p_{\theta}) = \argmax\limits_{\theta} \mathbb{E}_{\mathbf{x} \sim p_{\text{data}}(\mathbf{x})}[\log (p_{\theta}(\mathbf{x}))] \approx \argmax\limits_{\theta} \frac{1}{n} \sum_{i=1}^{n}\log (p_{\theta}(\mathbf{x}^{(i)})) \end{align}\] <h2 id="maximum-likelihood-estimation">Maximum Likelihood Estimation</h2> <p>In parallel with our exploration of KL-divergence, Maximum Likelihood Estimation (MLE) offers a complementary perspective. MLE find the parameter \(\theta^{*}\) that maximizes the likelihood of observing the dataset under the model. More formally, given the i.i.d samples \(\mathbf{x}^{(1)}, \mathbf{x}^{(2)}, \dots, \mathbf{x}^{(n)}\), we can write the MLE objective as:</p> \[\begin{align} \theta^{*}_{\text{MLE}} &amp;= \argmax\limits_{\theta} p_{\theta}(\mathbf{x}^{(1)}, \mathbf{x}^{(2)}, \dots, \mathbf{x}^{(n)}) \\ &amp;= \argmax\limits_{\theta} \prod_{i=1}^{n}p_{\theta}(\mathbf{x}^{(i)}) \\ &amp;= \argmax\limits_{\theta} \log \left(\prod_{i=1}^{n}p_{\theta}(\mathbf{x}^{(i)}) \right) \\ &amp;= \argmax\limits_{\theta} \sum_{i=1}^{n} \log p_{\theta}(\mathbf{x}^{(i)}) \\ \end{align}\] <p>We can start to see the similarity in the formula.</p> <h2 id="relationship-between-mle-and-kl-divergence">Relationship between MLE and KL-Divergence</h2> <p>The equations above show the connection between MLE and KL-divergence. In MLE, our goal is to find the parameter set \(\theta^{*}_{\text{MLE}}\) that maximizes the log-likelihood of our observed dataset. Conversely, in the context of KL-divergence, we minimize the distance between the model distribution with the true data distribution. The connection can be shown as follows:</p> \[\begin{align} \theta^{*}_{\text{KL}} &amp;= \argmin\limits_{\theta} D_{\text{KL}}(p_{\text{data}} || p_{\theta}) \\ &amp;\approx \argmax\limits_{\theta} \frac{1}{n} \sum_{i=1}^{n}\log (p_{\theta}(\mathbf{x}^{(i)})) \\ &amp;= \argmax\limits_{\theta} \sum_{i=1}^{n}\log (p_{\theta}(\mathbf{x}^{(i)})) \\ &amp;= \theta^{*}_{\text{MLE}} \end{align}\] <p>The practical significance of this duality lies in its utility for constructing probabilistic models and understanding the core of machine learning inference. Doing the MLE of our model distribution ensures that our model’s assumptions reflect reality as closely as possible. Consider two probability models \(f\) and \(g\), parameterized by a set of parameters \(\theta\). The figure below represents the application of MLE to find the optimal parameters.</p> <p><img class="img-fluid rounded z-depth-1" src="/assets/img/kl-mle-figure.jpg" alt="KL-MLE Figure" data-zoomable=""/></p> <p><br/> The optimal parameters \(\theta^{*}\) for our models \(f\) and \(g\), namely \(f_{\theta^{*}}\) and \(g_{\theta^{*}}\), are those that minimizes the KL-divergence to \(p_{\text{data}}\). Therefore, when we employ MLE, we are implicitly minimizing the KL Divergence between our model’s distribution and the true distribution of the data.</p> <h2 id="limitations">Limitations</h2> <table> <tbody> <tr> <td>This approach, however, encounters a fundamental limitation due to the elusive nature of \(p_{\text{data}}\), making it impossible to directly compute $$D_{\text{KL}}(p_{\text{data}}</td> <td> </td> <td>p_{\theta})\(. While we can estimate\)\mathbb{E}<em>{\mathbf{x} \sim p</em>{\text{data}}(\mathbf{x})}[\log (p_{\theta}(\mathbf{x}))]$$ using sampling methods, the following expression:</td> </tr> </tbody> </table> \[D_{\text{KL}}(p_{\text{data}}||p_{\theta}) = \mathbb{E}_{\mathbf{x} \sim p_{\text{data}}(\mathbf{x})}\left[\log \left(\frac{p_{\text{data}}(\mathbf{x})}{p_{\theta}(\mathbf{x})}\right)\right] = \mathbb{E}_{\mathbf{x} \sim p_{\text{data}}(\mathbf{x})}\left[\log (p_{\text{data}}(\mathbf{x}))] - \mathbb{E}_{\mathbf{x} \sim p_{\text{data}}(\mathbf{x})}[\log (p_{\theta}(\mathbf{x}))\right]\] <p>Depends on the term \(\mathbb{E}_{\mathbf{x} \sim p_{\text{data}}(\mathbf{x})}[\log (p_{\text{data}}(\mathbf{x}))]\), which remains unknown. Future explorations must focus on developing innovative approaches or refining existing methods to better approximate or understand \(p_{\text{data}}\). Such advancements are crucial for enhancing the accuracy and reliability of model predictions, ultimately pushing the boundaries of our understanding in this field.</p>]]></content><author><name></name></author><category term="generative-models"/><category term="MLE"/><category term="KL"/><category term="optimization"/><summary type="html"><![CDATA[Explaining the connection between MLE and KL Divergence in Generative Modeling]]></summary></entry></feed>